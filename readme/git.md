# チームでのgit学習

## 🚩 Table of Contents

- [ブランチについて](#ブランチについて)
- [clone後の３つのコマンドと理由](#clone後の３つのコマンドと理由)
- [PRを書く](#PRを書く)
- [git stash](#gitstash)
- [git rebase](#gitrebase)
- [コンフリクトの解決方法](#コンフリクトの解決方法)

## ブランチについて

- [Git style Guide 日本語訳はここから！](https://github.com/objectx/git-style-guide#%E3%83%96%E3%83%A9%E3%83%B3%E3%83%81)

### git ブランチは**カテゴリで開始**し、大文字は使用しない

一般的に**カテゴリで開始することが多い。**<br>
<理由>

- GUIなど見るときに`ブランチ名/〜〜`と作成することでみやすくなるから。 <br>
=> マージしていく際も便利になる！◎ (  `/` はファイルを分けることを意味する。)
- カテゴリ(目的)を含めることで、**チーム全体がどの機能に取り組んでいるかを理解**しやすくなる。
- 名前は多少、**抽象的**でOK<br>
=>**複数コミットのまとめ的な存在**なので簡潔に書くこと！

**<よく使用されるカテゴリ名一覧>**
| naming | use | 補足 |
| --- | --- | --- |
| feature | 機能の追加、リファクタリング |  |
| bugfix | バグ修正 |  |
| hotfix | 緊急の修正を行う | リリースした後、緊急のバグへの対応の際に使用されることが多い。 |
| test | test用 |  |
> refactoring : プログラムの動きを変えないまま、ソースコードを書き換えること

### 大文字は使用しない

**gitは基本大文字小文字の区別ができない**ため。(OSによっても判断できない)<br>

### ハイフン（-）を使用し、アンダースコア(_)は使わないこと

**人間と機械が読みやすく、意味のある**コミットメッセージにするための仕様(ルール)もある<br>

- [commitメッセージ規則](https://www.conventionalcommits.org/en/v1.0.0/)
[git conventionalcommits README](https://github.com/conventional-commits/conventionalcommits.org)

# clone後しないといけないこと３つと,その理由

**1.`bundle install`**

gemなどは**容量が重いからgitignoreと、gemfileにだけ書いてgitに保存してあった状態**

なので必須コマンド。
(gemなどのパッケージはこのように基本的にgitに(リモートに)pushされて保存されない。)
(bundle installというのはbundler gemが入っていないと使えないコマンド)

**２. `yarn install`**

⇒ **package.jsonにリスト化されている全ての依存関係を
node_modules 内にインストールするコマンド。**

 JS系もインストールが必要なので必須。

> **yarnとは**
jsのパッケージを管理できるパッケージマネージャのこと。
>

> **パッケージとは**
コンピュータに何のソフトウェアがインストールされたかを記録し、
新しいソフトウェアのインストール・新しいバージョンへのソフトウェアの更新、
以前インストールしたソフトウェアの削除を容易に行えるようにするプログラムのこと。
ライブラリもこの中の一つ。
>
**３. `rails db:migraqte`**<br>
DBもからになってるからもう一度インストール

# PRを書く

![](https://storage.googleapis.com/zenn-user-upload/3d0d3b3cac75-20230221.jpg)

- 赤枠部分、**マージ先の選択は間違わないように注意！**
- 右サイドにある**ラベル**とかつけるとよりわかりやすくなって良い！

# git stash

**コミット前の内容を一時的に退避しておくもの**。作業を一時避難させるもの。

## 使用場面

**コミットはしたくないが、変更履歴は残しておきたいとき。**<br>
作業中でコミットしたくないが、別ブランチで作業しないといけない…など。

### コマンド

`git add`で一回ステージに上げたのちに、`git stash save`<br>
**このsaveは省略可能**で、`git stash`で使用する。
> stash:隠す　の意味

## 仕組み

この `git stash`を行うことで、**ワークツリーとステージでの変更は無かったことにして**
stashという場所に置いておいて(隠しておき)、**それらの変更は無かったことにする**のだ。

![](https://storage.googleapis.com/zenn-user-upload/c374f48fdc46-20230222.jpg)

=> `git status`で見てみると、変更状態であったファイルがなくなってることが確認できるよ。

>`git status`
>作業ディレクトリの状態とステージング エリアの状態を表示するコマンド

## stashしたものの一覧が見たい： `git stash list`

![](https://storage.googleapis.com/zenn-user-upload/3662660844d7-20230222.png)

　このように `git stash　list`を行うことで全ての避難した作業を確認することが可能です。

## stashで隠した変更文を復元: `git stash apply`
>
>apply: 適用する　の意味
>
### コマンド

- `git stash apply`　 最新の作業復元
- `git stash apply stash名` 特定の作業の復元
- `git stash apply stash@{1}`これも特定の作業の復元
これらの特定のものは上記したように、`git stash list`で確認してね！
stash＠{}の波括弧の中の番号は、listでみた時の一番左のものだよ。

**上記三つは、ステージの状況までは復元されない。**

- `git stash apply --index`ステージの作業も復元

## stashしたものを削除：　git stash drop

### コマンド

- `git stash drop` 最新の作業を削除
- `git stash drop stash名` 特定の作業の削除
- `git stash drop stash@{1}` これも特定の作業の削除
- `git stash drop clear` 全作業を削除

# git rebase

最初に簡単に言うと、**変更を統合するとき、履歴をきれいに整えるために使用するもの。**<br>
指定したコミットを、ひとまとめにしたりして、**ログを綺麗にするコマンド**。

**rebaseを理解するために、まずは基本のpullの方向性(mergeとrebaseの違い)について**の理解が
必要になる.

# pullの方向性(mergeとrebaseの違い)

そもそも、pullは簡単に言えば、”引っ張ってくる”の意味だが、<br>
その引っ張ってきた後で、
**方向性(つながり方)によって、以下のように３通りに分かれる。**
![](https://storage.googleapis.com/zenn-user-upload/dee6fa8b1b17-20230224.jpg)

そして、mergeとrebaseのつながり方はこのような感じだ.
![](https://storage.googleapis.com/zenn-user-upload/c04110126a0f-20230224.jpg)

上記したA,B,C…はブランチで、mergeとrebaseのつながり方の図だ。<br>
**margeも、rebaseも、合わせる(ブランチを統合する)の意味では一緒**だ。
違いは、その繋がり方だ。

## merge

自分のブランチへ、**他のブランチの更新を取り込んで最新のブランチとする**。

## rebase

上記の絵で言うと、
元々DはBから切ったわけだが、このDブランチがrebaseコマンドを行うことで、
B->Cの**変更分を取り込んで、(分岐開始場所を変更して)最新ブランチとする**こと。

要するに、
**ブランチの基点(切った場所)となるブランチを、別のブランチに移動する**こと。
そして、**その間の他のブランチでの変更分も自分に取り込み**最新ブランチにする。
＝　コミットの**履歴もきれいに一直線になる(複雑にならない)**
= git logも確認しやすくなる。

> 一言メモ：rebaseという名前の意味は？！
> re: 再び 　/  base:基点　　
> 親のコミット(ブランチ)=base　を、新しくするの意味。

ここまでの説明で、違いや特徴はわかっただろうか。
ここまでの違いを理解したら、rebaseの使用場面がわかってくる.

**【主要な使い方】**

- 不要なマージコミットのないすっきりした、直線的な履歴にする
( 開発コミットを繋げ直す.別々のブランチで伸ばしていた開発コミットを繋げ直す )
- **複数コミットを1コミットにまとめる**

# コンフリクトの解決方法

## リモートでコンフリクトの発生を確認

![](https://storage.googleapis.com/zenn-user-upload/281c786d6228-20230225.jpg)

このように、**PRのページでみると、コンフリクトが確認**でき、
マージしようとしてもできないことが確認できます。

このページの**resolve conflictsボタンで、修正箇所を見ることができる**し、修正もできます。<br>
しかし！！！！ <br>
**ここでは基本しないこと！**<br>
=> リモートのみでの修正になり、ローカルにプルした際に、またそっちでも修正しないといけなく、二度手間だから。

## ローカルに戻りそのままpullし、手動で修正

![](https://storage.googleapis.com/zenn-user-upload/da9438d0af7e-20230225.jpg)

このように、**pullするとhintがたくさん出てきます**。**設定してね**の記述です。

[**merge,rebase,fast-fowardの３つのどれかで設定してください**]と、言っています。

今回は、**rebaseでの修正**方法を行なっていきます。

## pullの方向をrebaseに設定

### 今回はrebaseで行なっていきます

以下のコマンドを打ち設定します。

`git config --global pull.rebase true`

このコマンドで設定完了です。
そしてこのように、コンフリクトの内容を明記してくれます。

![](https://storage.googleapis.com/zenn-user-upload/8f45d4c3f273-20230225.png)
今回は、top.htmlで発生しているので開きます。

![](https://storage.googleapis.com/zenn-user-upload/2c1f3f3d9117-20230225.png)

選択肢が表記されているので、残すものを選択しましょう。
両方も可能だし、片方も可能です。

### 修正後

**修正したら、`git add .`を**行い、変更をステージに上げましょう。<br>
そして**コミットはせず、以下のコマンド実行**しましょう。

`git rebase --continue`

これはもう一度rebaseを行うと言うことです。
(=　修正を踏まえて、統合実行！)

### コミットメッセージの変更可能

このように、前回のコミットメッセージが出てきます。
ここのコミットに、**rebaseした内容も含むようになるので、変更できるようになっています**。

![](https://storage.googleapis.com/zenn-user-upload/d8e4a4175268-20230225.jpg)

ビームモードで表記されているので、コミットメッセージを変更しようとしてもできません。<br>
=>**キーボードの i を押すことでinsertモードに代わり入力可能に！**

変更し終えたら、出ます。
(エンターできるようにするため)<br>
**esc　を押して、　`:wq!`　を入力。**
> w: wright　書く
> q: quit 出る

**これも終わったら、pushしましょう。**

するとこのようにでます。

![](https://storage.googleapis.com/zenn-user-upload/db42b39f1fd5-20230225.png)

これが出るのは、リモートと差があるからです.
(rebaseして修正してるので当たり前です。)

なので、次は…

### rebaseの時のみ、ーーforce使用

同じ開発チームの人とも確認した上で、

**`git push origin HEAD --force` で強制pushです。**

**コンフリクト解消です！！！**

これで、リモートに戻ると、マージも可能になっています！

![](https://storage.googleapis.com/zenn-user-upload/030678a957d3-20230225.png)
